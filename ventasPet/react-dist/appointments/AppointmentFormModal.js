function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
import React from 'react';
import { Controller, useForm, useWatch } from 'react-hook-form';
import { useState } from 'react';
import { CustomModal } from "../components/CustomModal.js";
import { classNames } from 'primereact/utils';
import { Dropdown } from 'primereact/dropdown';
import { useUserSpecialties } from "../user-specialties/hooks/useUserSpecialties.js";
import { useEffect } from 'react';
import { Calendar } from 'primereact/calendar';
import { userAvailabilityService, userService } from "../../services/api/index.js";
import { RadioButton } from 'primereact/radiobutton';
import { stringToDate } from "../../services/utilidades.js";
import { useProducts } from "../products/hooks/useProducts.js";
import { externalCauses as commonExternalCauses, purposeConsultations, typeConsults } from "../../services/commons.js";
import { usePatients } from "../patients/hooks/usePatients.js";
import { InputText } from 'primereact/inputtext';
import { Card } from 'primereact/card';
import { Checkbox } from 'primereact/checkbox';
import { InputNumber } from 'primereact/inputnumber';
import { useAppointmentBulkCreate } from "./hooks/useAppointmentBulkCreate.js";
import { usePatientExamRecipes } from "../exam-recipes/hooks/usePatientExamRecipes.js";
import { useValidateBulkAppointments } from "./hooks/useValidateBulkAppointments.js";
import { Tooltip } from 'primereact/tooltip';
export const AppointmentFormModal = ({
  isOpen,
  onClose
}) => {
  const [appointments, setAppointments] = useState([]);
  const [currentAppointment, setCurrentAppointment] = useState(null);
  const [editingId, setEditingId] = useState(null);
  const [formValid, setFormValid] = useState(false);
  const [appointmentDateDisabled, setAppointmentDateDisabled] = useState(true);
  const [appointmentTimeDisabled, setAppointmentTimeDisabled] = useState(true);
  const [userAvailabilityDisabled, setUserAvailabilityDisabled] = useState(true);
  const [showUserSpecialtyError, setShowUserSpecialtyError] = useState(false);
  const [userSpecialtyError, setUserSpecialtyError] = useState('');
  const [showRecurrentFields, setShowRecurrentFields] = useState(false);
  const [appointmentFrequency, setAppointmentFrequency] = useState('diary');
  const [appointmentRepetitions, setAppointmentRepetitions] = useState(1);
  const [appointmentTimeOptions, setAppointmentTimeOptions] = useState([]);
  const [userAvailabilityOptions, setUserAvailabilityOptions] = useState([]);
  const [assistantAvailabilityOptions, setAssistantAvailabilityOptions] = useState([]);
  const [availableBlocks, setAvailableBlocks] = useState([]);
  const [enabledDates, setEnabledDates] = useState([]);
  const {
    userSpecialties
  } = useUserSpecialties();
  const {
    products
  } = useProducts();
  const {
    patients
  } = usePatients();
  const {
    createAppointmentBulk
  } = useAppointmentBulkCreate();
  const {
    validateBulkAppointments
  } = useValidateBulkAppointments();
  const {
    patientExamRecipes,
    setPatientExamRecipes,
    fetchPatientExamRecipes
  } = usePatientExamRecipes();
  const consultationPurposes = Object.entries(purposeConsultations).map(([key, value]) => ({
    value: key,
    label: value
  }));
  const consultationTypes = Object.entries(typeConsults).map(([key, value]) => ({
    value: key,
    label: value
  }));
  const externalCauses = Object.entries(commonExternalCauses).map(([key, value]) => ({
    value: key,
    label: value
  }));
  const frequencies = [{
    value: 'diary',
    label: 'Diario'
  }, {
    value: 'weekly',
    label: 'Semanal'
  }, {
    value: 'monthly',
    label: 'Mensual'
  }, {
    value: 'bimestral',
    label: 'Bimestral'
  }, {
    value: 'semestral',
    label: 'Semestral'
  }, {
    value: 'annual',
    label: 'Anual'
  }];
  const {
    control,
    register,
    reset,
    handleSubmit,
    setValue,
    getValues,
    formState: {
      errors
    }
  } = useForm({
    defaultValues: {
      uuid: '',
      appointment_date: null,
      appointment_time: '',
      assigned_user_availability: null,
      appointment_type: '1'
    }
  });
  const mapAppointmentsToServer = async appointments => {
    const currentUser = await userService.getLoggedUser();
    return appointments.map(app => {
      const assignedUserAvailability = app.assigned_user_assistant_availability_id || app.assigned_user_availability?.id;
      const supervisorUserId = app.assigned_user_assistant_availability_id ? app.assigned_user_availability?.id : null;
      return {
        "appointment_date": app.appointment_date?.toISOString().split('T')[0],
        "appointment_time": app.appointment_time + ":00",
        "assigned_user_availability_id": assignedUserAvailability,
        "product_id": app.product_id,
        "created_by_user_id": currentUser?.id,
        "appointment_state_id": 1,
        "attention_type": "CONSULTATION",
        "consultation_purpose": app.consultation_purpose,
        "consultation_type": app.consultation_type,
        "external_cause": app.external_cause,
        "assigned_supervisor_user_availability_id": supervisorUserId,
        "exam_recipe_id": app.exam_recipe_id
      };
    });
  };
  const addAppointments = async data => {
    if (editingId && appointments.find(app => app.uuid === editingId)) {
      setAppointments(appointments.map(app => app.uuid === editingId ? {
        ...app,
        ...data
      } : app));
      setEditingId(null);
      clearAppointmentForm();
    } else {
      const newAppointments = [];
      let currentDate = data.appointment_date ? new Date(data.appointment_date) : null;
      for (let i = 0; i < (appointmentRepetitions || 1); i++) {
        if (currentDate) {
          const appointmentDateCopy = new Date(currentDate);
          const newAppointment = {
            ...data,
            uuid: crypto.randomUUID(),
            appointment_date: appointmentDateCopy
          };
          newAppointments.push(newAppointment);
          switch (appointmentFrequency) {
            case 'diary':
              currentDate.setDate(currentDate.getDate() + 1);
              break;
            case 'weekly':
              currentDate.setDate(currentDate.getDate() + 7);
              break;
            case 'monthly':
              currentDate.setMonth(currentDate.getMonth() + 1);
              break;
            case 'bimestral':
              currentDate.setMonth(currentDate.getMonth() + 2);
              break;
            case 'semestral':
              currentDate.setMonth(currentDate.getMonth() + 6);
              break;
            case 'annual':
              currentDate.setFullYear(currentDate.getFullYear() + 1);
              break;
            default:
              currentDate.setDate(currentDate.getDate() + 1);
              break;
          }
        }
      }
      const validatedAppointments = await validateAppointments(newAppointments);
      setAppointments(prev => [...prev, ...validatedAppointments]);
    }
  };
  const validateAppointments = async _appointments => {
    const mappedAppointments = await mapAppointmentsToServer(_appointments);
    try {
      await validateBulkAppointments(mappedAppointments, patient?.id.toString() || '');

      // Si la validación es exitosa, limpiamos los errores
      return _appointments.map(appointment => ({
        ...appointment,
        errors: {}
      }));
    } catch (error) {
      if (error.response?.status === 422) {
        // Parseamos el error correctamente
        const errorData = error.data?.errors || {};
        return _appointments.map((appointment, index) => ({
          ...appointment,
          errors: errorData[index.toString()] || {}
        }));
      }

      // En caso de otros errores, mantenemos las citas como están
      return _appointments;
    }
  };
  const onSubmit = async e => {
    e.preventDefault();
    const data = await mapAppointmentsToServer(appointments);
    const res = await createAppointmentBulk({
      appointments: data
    }, patient.id.toString());
  };
  const userSpecialty = useWatch({
    control,
    name: 'user_specialty'
  });
  const showExamRecipeField = useWatch({
    control,
    name: 'show_exam_recipe_field'
  });
  const appointmentDate = useWatch({
    control,
    name: 'appointment_date'
  });
  const appointmentTime = useWatch({
    control,
    name: 'appointment_time'
  });
  const appointmentType = useWatch({
    control,
    name: 'appointment_type'
  });
  const patient = useWatch({
    control,
    name: 'patient'
  });
  const assignedUserAvailability = useWatch({
    control,
    name: 'assigned_user_availability'
  });
  useEffect(() => {
    if (patient) {
      fetchPatientExamRecipes(patient.id.toString());
    } else {
      setPatientExamRecipes([]);
    }
  }, [patient?.id]);
  useEffect(() => {
    if (userSpecialty) {
      setShowUserSpecialtyError(false);
      setValue('appointment_date', null);
      setAppointmentTimeOptions([]);
      const asyncScope = async () => {
        const availableBlocks = await userAvailabilityService.availableBlocks({
          user_specialty_id: userSpecialty?.id
        });
        console.log('availableBlocks', availableBlocks);
        setAvailableBlocks(availableBlocks);
        if (availableBlocks.length > 0) {
          setAppointmentDateDisabled(false);
          setAppointmentTimeDisabled(false);
          setUserAvailabilityDisabled(false);
        } else {
          setShowUserSpecialtyError(true);
          setUserSpecialtyError(userSpecialty?.label);
        }
        setEnabledDates([]);
        let availableDates = [];
        availableBlocks.forEach(item => {
          item.days.forEach(day => {
            if (!enabledDates.includes(day.date)) {
              availableDates.push(stringToDate(day.date));
            }
          });
        });
        setEnabledDates(availableDates);
        updateAppointmentTimeOptions(availableBlocks, availableDates[0]);
      };
      asyncScope();
    } else {
      setShowUserSpecialtyError(false);
      setAppointmentDateDisabled(true);
      setAppointmentTimeDisabled(true);
      setUserAvailabilityDisabled(true);
      setValue('appointment_date', null);
      setValue('appointment_time', '');
      setValue('assigned_user_availability', null);
      setAvailableBlocks([]);
      setEnabledDates([]);
      setAppointmentTimeOptions([]);
      setUserAvailabilityOptions([]);
    }
  }, [userSpecialty]);
  useEffect(() => {
    if (appointmentDate) {
      updateAppointmentTimeOptions(availableBlocks, appointmentDate);
    }
  }, [appointmentDate]);
  useEffect(() => {
    if (appointmentTime && appointmentDate) {
      filterDoctors(availableBlocks, appointmentDate.toISOString().split('T')[0], appointmentTime, appointmentType);
    }
  }, [appointmentTime]);
  useEffect(() => {
    if (appointmentType && appointmentDate && appointmentTime) {
      filterDoctors(availableBlocks, appointmentDate.toISOString().split('T')[0], appointmentTime, appointmentType);
    }
  }, [appointmentType]);
  useEffect(() => {
    if (assignedUserAvailability) {
      const currentAvailableUserIds = userAvailabilityOptions.map(availability => availability.user.id);
      const userAssistantAvailabilities = assignedUserAvailability.user.assistants.map(assistant => {
        if (!currentAvailableUserIds.includes(assistant.id)) {
          return null;
        }
        return {
          id: assistant.id,
          label: `${assistant.first_name} ${assistant.middle_name} ${assistant.last_name} ${assistant.second_last_name}`,
          value: assistant.id
        };
      }).filter(assistant => assistant !== null);
      if (userAssistantAvailabilities.length > 0) {
        setAssistantAvailabilityOptions(userAssistantAvailabilities);
        setValue('assigned_user_assistant_availability_id', currentAppointment?.assigned_user_assistant_availability_id || null);
      } else {
        setAssistantAvailabilityOptions([]);
        setValue('assigned_user_assistant_availability_id', null);
      }
    } else {
      setAssistantAvailabilityOptions([]);
      setValue('assigned_user_assistant_availability_id', null);
    }
  }, [assignedUserAvailability]);
  useEffect(() => {
    if (editingId === null) {
      setCurrentAppointment(null);
    }
  }, [editingId]);
  useEffect(() => {
    if (patient) {
      const whatsapp = patient.whatsapp || '';
      const email = patient.email || '';
      if (getValues('patient_whatsapp') !== whatsapp) {
        setValue('patient_whatsapp', whatsapp);
      }
      if (getValues('patient_email') !== email) {
        setValue('patient_email', email);
      }
    } else {
      setValue('patient_whatsapp', '');
      setValue('patient_email', '');
    }
  }, [patient?.id, patient?.whatsapp, patient?.email]);
  useEffect(() => {
    if (!enabledDates.length) return;
    setValue('appointment_date', currentAppointment?.appointment_date || enabledDates.length > 0 ? enabledDates.sort((a, b) => a.getTime() - b.getTime())[0] : null);
  }, [enabledDates]);
  useEffect(() => {
    if (appointmentTimeOptions.length > 0 && appointmentDate) {
      const selectedTime = appointmentTimeOptions.length > 0 ? appointmentTimeOptions[0].value : null;
      setValue('appointment_time', currentAppointment?.appointment_time || selectedTime || null);
      filterDoctors(availableBlocks, appointmentDate?.toISOString().split('T')[0], currentAppointment?.appointment_time || selectedTime);
    }
  }, [appointmentTimeOptions]);
  useEffect(() => {
    setFormValid(appointments.length > 0 && !!patient);
  }, [appointments, patient]);
  const handleRemove = id => {
    setAppointments(appointments.filter(app => app.uuid !== id));
  };
  const handleEdit = appointment => {
    setEditingId(appointment.uuid);
    fillAppointmentForm(appointment);
  };
  const handleClear = () => {
    clearAppointmentForm();
    setEditingId(null);
  };
  const handleCopy = appointment => {
    setEditingId(null);
    fillAppointmentForm(appointment);
  };
  const fillAppointmentForm = appointment => {
    setCurrentAppointment(appointment);
    setValue('user_specialty', appointment.user_specialty);
    setValue('show_exam_recipe_field', appointment.show_exam_recipe_field);
    setValue('exam_recipe_id', appointment.exam_recipe_id);
    setValue('appointment_type', appointment.appointment_type);
    setValue('product_id', appointment.product_id);
    setValue('consultation_purpose', appointment.consultation_purpose);
    setValue('consultation_type', appointment.consultation_type);
    setValue('external_cause', appointment.external_cause);
    setShowRecurrentFields(false);
    setAppointmentFrequency('diary');
    setAppointmentRepetitions(1);
  };
  const clearAppointmentForm = () => {
    setValue('user_specialty', null);
    setValue('show_exam_recipe_field', false);
    setValue('exam_recipe_id', null);
    setValue('appointment_type', '1');
    setValue('appointment_date', null);
    setValue('appointment_time', null);
    setValue('assigned_user_availability', null);
    setValue('product_id', null);
    setValue('consultation_purpose', null);
    setValue('consultation_type', null);
    setValue('external_cause', null);
    setShowRecurrentFields(false);
    setAppointmentFrequency('diary');
    setAppointmentRepetitions(1);
    setEditingId(null);
  };
  const getFormErrorMessage = name => {
    return errors[name] && errors[name].type !== 'required' && /*#__PURE__*/React.createElement("small", {
      className: "p-error"
    }, errors[name].message);
  };
  const hasValidationErrors = () => {
    return appointments.some(appointment => {
      return Object.keys(appointment.errors).length > 0;
    });
  };
  const computeTimeSlots = (start, end, duration) => {
    const slots = [];
    let current = new Date(`1970-01-01T${start}`);
    const endTime = new Date(`1970-01-01T${end}`);
    while (current.getTime() + duration * 60000 <= endTime.getTime()) {
      const hours = current.getHours().toString().padStart(2, '0');
      const minutes = current.getMinutes().toString().padStart(2, '0');
      slots.push(`${hours}:${minutes}`);
      current = new Date(current.getTime() + duration * 60000);
    }
    return slots;
  };
  function filterDoctors(availableBlocks, selectedDate, selectedTime, appointmentType = '1') {
    const selectedTimeDate = new Date(`1970-01-01T${selectedTime}`);
    let availableAvailabilities = [];
    let filteredAvailableBlocks = availableBlocks.filter(item => item.appointment_type.id == appointmentType);
    filteredAvailableBlocks.forEach(item => {
      item.days.forEach(day => {
        if (day.date === selectedDate) {
          day.blocks.forEach(block => {
            const blockStart = new Date(`1970-01-01T${block.start_time}`);
            const blockEnd = new Date(`1970-01-01T${block.end_time}`);
            if (selectedTimeDate >= blockStart && selectedTimeDate < blockEnd) {
              availableAvailabilities.push(item);
            }
          });
        }
      });
    });
    const uniqueAvailabilities = [];
    const seenIds = new Set();
    availableAvailabilities.forEach(avail => {
      if (!seenIds.has(avail.availability_id)) {
        seenIds.add(avail.availability_id);
        uniqueAvailabilities.push(avail);
      }
    });
    const doctorOptions = uniqueAvailabilities.map(avail => ({
      ...avail,
      id: avail.availability_id,
      full_name: `${avail.user.first_name || ''} ${avail.user.middle_name || ''} ${avail.user.last_name || ''} ${avail.user.second_last_name || ''}`
    }));
    setUserAvailabilityOptions(doctorOptions);
    setValue('assigned_user_availability', currentAppointment?.assigned_user_availability || doctorOptions[0] || null);
  }
  const updateAppointmentTimeOptions = (availableBlocks, date) => {
    const dateString = date.toISOString().split('T')[0];
    setAppointmentTimeOptions([]);
    let blocks = [];
    availableBlocks.forEach(item => {
      item.days.forEach(day => {
        if (day.date === dateString) {
          day.blocks.forEach(block => {
            blocks.push({
              start: block.start_time,
              end: block.end_time,
              duration: item.appointment_duration,
              user: item.user,
              availability_id: item.availability_id
            });
          });
        }
      });
    });
    let options = [];
    blocks.forEach(block => {
      const slots = computeTimeSlots(block.start, block.end, block.duration);
      options = options.concat(slots.map(slot => ({
        time: slot,
        availability_id: block.availability_id,
        user: block.user
      })));
    });
    let uniqueOptions = [];
    const seenTimes = new Set();
    options.forEach(option => {
      if (!seenTimes.has(option.time)) {
        seenTimes.add(option.time);
        uniqueOptions.push(option);
      }
    });
    uniqueOptions.sort((a, b) => a.time.localeCompare(b.time));
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const todayDate = `${year}-${month}-${day}`;
    const currentTime = String(now.getHours()).padStart(2, '0') + ':' + String(now.getMinutes()).padStart(2, '0');
    if (appointmentDate?.toISOString().split('T')[0] === todayDate) {
      uniqueOptions = uniqueOptions.filter(opcion => opcion.time >= currentTime);
    }
    setAppointmentTimeOptions(uniqueOptions.map(opcion => ({
      label: opcion.time,
      value: opcion.time
    })));
  };
  return /*#__PURE__*/React.createElement(CustomModal, {
    show: isOpen,
    onHide: onClose,
    title: "Crear cita"
  }, /*#__PURE__*/React.createElement("form", {
    className: "needs-validation row",
    noValidate: true,
    onSubmit: onSubmit
  }, /*#__PURE__*/React.createElement("div", {
    className: "col-12"
  }, /*#__PURE__*/React.createElement("div", {
    className: "mb-3"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "patient",
    control: control,
    rules: {
      required: 'Este campo es requerido'
    },
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Paciente *"), /*#__PURE__*/React.createElement(Dropdown, _extends({
      inputId: field.name,
      options: patients,
      optionLabel: "label",
      filter: true,
      showClear: true,
      placeholder: "Seleccione un paciente",
      className: classNames('w-100', {
        'p-invalid': errors.patient
      }),
      appendTo: 'self'
    }, field)))
  }), getFormErrorMessage('patient')), /*#__PURE__*/React.createElement("div", {
    className: "row"
  }, /*#__PURE__*/React.createElement("div", {
    className: "col-md-6 mb-3"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "patient_whatsapp",
    control: control,
    rules: {
      required: 'Este campo es requerido'
    },
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Whatsapp *"), /*#__PURE__*/React.createElement(InputText, _extends({
      id: field.name,
      className: classNames('w-100', {
        'p-invalid': errors.patient_whatsapp
      })
    }, field)))
  }), getFormErrorMessage('patient_whatsapp')), /*#__PURE__*/React.createElement("div", {
    className: "col-md-6 mb-3"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "patient_email",
    control: control,
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Email"), /*#__PURE__*/React.createElement(InputText, _extends({
      id: field.name,
      className: classNames('w-100', {
        'p-invalid': errors.patient_email
      })
    }, field)))
  })))), /*#__PURE__*/React.createElement("div", {
    className: "col-12 px-3 mb-3"
  }, /*#__PURE__*/React.createElement(Card, null, /*#__PURE__*/React.createElement("div", {
    className: "row"
  }, /*#__PURE__*/React.createElement("div", {
    className: "col-md-7"
  }, /*#__PURE__*/React.createElement("div", {
    className: "mb-3"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "user_specialty",
    control: control,
    rules: {
      required: 'Este campo es requerido'
    },
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Especialidad m\xE9dica *"), /*#__PURE__*/React.createElement(Dropdown, _extends({
      inputId: field.name,
      options: userSpecialties,
      optionLabel: "label",
      filter: true,
      showClear: true,
      placeholder: "Seleccione una especialidad",
      className: classNames('w-100', {
        'p-invalid': errors.user_specialty
      }),
      appendTo: 'self'
    }, field)))
  }), getFormErrorMessage('user_specialty')), /*#__PURE__*/React.createElement("div", {
    className: "d-flex align-items-center gap-2 mb-3"
  }, /*#__PURE__*/React.createElement(Checkbox, {
    inputId: "showExamRecipeField",
    name: "showExamRecipeField",
    checked: showExamRecipeField,
    onChange: e => setValue('show_exam_recipe_field', e.target.checked || false)
  }), /*#__PURE__*/React.createElement("label", {
    htmlFor: "showExamRecipeField",
    className: "ml-2 form-check-label"
  }, "Relacionar receta de examen")), showExamRecipeField && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    className: "mb-3"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "exam_recipe_id",
    control: control,
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Receta de examen"), /*#__PURE__*/React.createElement(Dropdown, _extends({
      inputId: field.name,
      options: patientExamRecipes,
      optionLabel: "label",
      optionValue: "id",
      filter: true,
      showClear: true,
      placeholder: "Seleccione una receta de examen",
      className: classNames('w-100', {
        'p-invalid': errors.exam_recipe_id
      }),
      appendTo: 'self'
    }, field)))
  }), getFormErrorMessage('exam_recipe_id'))), showUserSpecialtyError && /*#__PURE__*/React.createElement("div", {
    className: "alert alert-danger",
    role: "alert"
  }, "No hay especialistas de: ", /*#__PURE__*/React.createElement("span", null, userSpecialtyError), " disponibles en este momento"), /*#__PURE__*/React.createElement("div", {
    className: "mb-3"
  }, /*#__PURE__*/React.createElement("label", {
    className: "form-label mb-2"
  }, "Tipo de cita *"), /*#__PURE__*/React.createElement("div", {
    className: "d-flex flex-wrap gap-3"
  }, /*#__PURE__*/React.createElement("div", {
    className: "d-flex align-items-center gap-2"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "appointment_type",
    control: control,
    rules: {
      required: 'Este campo es requerido'
    },
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RadioButton, {
      inputId: field.name + '1',
      checked: appointmentType === '1',
      className: classNames('', {
        'p-invalid': errors.appointment_type
      }),
      value: "1",
      onChange: e => field.onChange(e.value)
    }), /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name + '1',
      className: "ml-2 form-check-label"
    }, "Presencial"))
  })), /*#__PURE__*/React.createElement("div", {
    className: "d-flex align-items-center gap-2"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "appointment_type",
    control: control,
    rules: {
      required: 'Este campo es requerido'
    },
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RadioButton, {
      inputId: field.name + '3',
      checked: appointmentType === '3',
      className: classNames('', {
        'p-invalid': errors.appointment_type
      }),
      onChange: e => field.onChange(e.value),
      value: "3"
    }), /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name + '3',
      className: "ml-2 form-check-label"
    }, "Domiciliaria"))
  })), /*#__PURE__*/React.createElement("div", {
    className: "d-flex align-items-center gap-2"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "appointment_type",
    control: control,
    rules: {
      required: 'Este campo es requerido'
    },
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RadioButton, {
      inputId: field.name + '2',
      checked: appointmentType === '2',
      className: classNames('', {
        'p-invalid': errors.appointment_type
      }),
      onChange: e => field.onChange(e.value),
      value: "2"
    }), /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name + '2',
      className: "ml-2 form-check-label"
    }, "Virtual"))
  }))), getFormErrorMessage('appointment_type')), /*#__PURE__*/React.createElement("div", {
    className: "mb-3"
  }, /*#__PURE__*/React.createElement("div", {
    className: "row"
  }, /*#__PURE__*/React.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "appointment_date",
    control: control,
    rules: {
      required: 'Este campo es requerido'
    },
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Fecha de la consulta *"), /*#__PURE__*/React.createElement(Calendar, {
      id: field.name,
      value: field.value,
      onChange: e => field.onChange(e.value),
      className: classNames('w-100', {
        'p-invalid': errors.appointment_date
      }),
      appendTo: 'self',
      disabled: appointmentDateDisabled,
      enabledDates: enabledDates,
      placeholder: "Seleccione una fecha"
    }))
  }), getFormErrorMessage('appointment_date')), /*#__PURE__*/React.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "appointment_time",
    control: control,
    rules: {
      required: 'Este campo es requerido'
    },
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Hora de la consulta *"), /*#__PURE__*/React.createElement(Dropdown, _extends({
      inputId: field.name,
      options: appointmentTimeOptions,
      virtualScrollerOptions: {
        itemSize: 38
      },
      optionLabel: "label",
      filter: true,
      placeholder: "Seleccione una hora",
      className: classNames('w-100', {
        'p-invalid': errors.appointment_time
      }),
      appendTo: 'self',
      disabled: appointmentTimeDisabled
    }, field)))
  }), getFormErrorMessage('appointment_time')))), /*#__PURE__*/React.createElement("div", {
    className: "mb-3"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "assigned_user_availability",
    control: control,
    rules: {
      required: 'Este campo es requerido'
    },
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Doctor(a) *"), /*#__PURE__*/React.createElement(Dropdown, _extends({
      inputId: field.name,
      options: userAvailabilityOptions,
      optionLabel: "full_name",
      filter: true,
      placeholder: "Seleccione un usuario",
      className: classNames('w-100', {
        'p-invalid': errors.assigned_user_availability
      }),
      appendTo: 'self',
      disabled: userAvailabilityDisabled
    }, field)))
  }), getFormErrorMessage('assigned_user_availability')), assistantAvailabilityOptions.length > 0 && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    className: "mb-3"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "assigned_user_assistant_availability_id",
    control: control,
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Asistente"), /*#__PURE__*/React.createElement(Dropdown, _extends({
      inputId: field.name,
      options: assistantAvailabilityOptions,
      optionLabel: "label",
      optionValue: "id",
      filter: true,
      showClear: true,
      placeholder: "Seleccione un asistente",
      className: classNames('w-100', {
        'p-invalid': errors.assigned_user_assistant_availability_id
      }),
      appendTo: 'self',
      disabled: userAvailabilityDisabled
    }, field)))
  }))), /*#__PURE__*/React.createElement("div", {
    className: "mb-3"
  }, /*#__PURE__*/React.createElement("div", {
    className: "row"
  }, /*#__PURE__*/React.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "product_id",
    control: control,
    rules: {
      required: 'Este campo es requerido'
    },
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Procedimiento *"), /*#__PURE__*/React.createElement(Dropdown, _extends({
      inputId: field.name,
      options: products,
      optionLabel: "label",
      optionValue: "id",
      virtualScrollerOptions: {
        itemSize: 38
      },
      filter: true,
      showClear: true,
      placeholder: "Seleccione un procedimiento",
      className: classNames('w-100', {
        'p-invalid': errors.product_id
      }),
      appendTo: 'self'
    }, field)))
  }), getFormErrorMessage('product_id')), /*#__PURE__*/React.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "consultation_purpose",
    control: control,
    rules: {
      required: 'Este campo es requerido'
    },
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Finalidad de la consulta *"), /*#__PURE__*/React.createElement(Dropdown, _extends({
      inputId: field.name,
      options: consultationPurposes,
      optionValue: "value",
      optionLabel: "label",
      filter: true,
      showClear: true,
      placeholder: "Seleccione una finalidad",
      className: classNames('w-100', {
        'p-invalid': errors.consultation_purpose
      }),
      appendTo: 'self'
    }, field)))
  }), getFormErrorMessage('consultation_purpose')))), /*#__PURE__*/React.createElement("div", {
    className: "mb-3"
  }, /*#__PURE__*/React.createElement("div", {
    className: "row"
  }, /*#__PURE__*/React.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "consultation_type",
    control: control,
    rules: {
      required: 'Este campo es requerido'
    },
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Tipo de consulta *"), /*#__PURE__*/React.createElement(Dropdown, _extends({
      inputId: field.name,
      options: consultationTypes,
      optionLabel: "label",
      optionValue: "value",
      filter: true,
      showClear: true,
      placeholder: "Seleccione un tipo de consulta",
      className: classNames('w-100', {
        'p-invalid': errors.consultation_type
      }),
      appendTo: 'self'
    }, field)))
  }), getFormErrorMessage('consultation_type')), /*#__PURE__*/React.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/React.createElement(Controller, {
    name: "external_cause",
    control: control,
    render: ({
      field
    }) => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
      htmlFor: field.name,
      className: "form-label"
    }, "Causa externa"), /*#__PURE__*/React.createElement(Dropdown, _extends({
      inputId: field.name,
      options: externalCauses,
      optionLabel: "label",
      optionValue: "value",
      filter: true,
      showClear: true,
      placeholder: "Seleccione una causa externa",
      className: classNames('w-100'),
      appendTo: 'self'
    }, field)))
  })))), /*#__PURE__*/React.createElement("div", {
    className: "mb-4"
  }, !editingId && /*#__PURE__*/React.createElement("div", {
    className: "d-flex align-items-center gap-2"
  }, /*#__PURE__*/React.createElement(Checkbox, {
    inputId: "recurrent",
    name: "recurrent",
    checked: showRecurrentFields,
    onChange: e => setShowRecurrentFields(e.target.checked || false)
  }), /*#__PURE__*/React.createElement("label", {
    htmlFor: "recurrent",
    className: "ml-2 form-check-label"
  }, "Cita recurrente")), showRecurrentFields && /*#__PURE__*/React.createElement("div", {
    className: "mt-3"
  }, /*#__PURE__*/React.createElement("div", {
    className: "row"
  }, /*#__PURE__*/React.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "appointment_frequency",
    className: "form-label"
  }, "Frecuencia de la cita"), /*#__PURE__*/React.createElement(Dropdown, {
    inputId: "appointment_frequency",
    options: frequencies,
    optionLabel: "label",
    optionValue: "value",
    filter: true,
    showClear: true,
    placeholder: "Seleccione una frecuencia",
    className: classNames('w-100'),
    appendTo: 'self',
    value: appointmentFrequency,
    onChange: e => setAppointmentFrequency(e.value)
  })), /*#__PURE__*/React.createElement("div", {
    className: "col-md-6"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "appointment_repetitions",
    className: "form-label"
  }, "N\xFAmero de repeticiones"), /*#__PURE__*/React.createElement(InputNumber, {
    inputId: "appointment_repetitions",
    value: appointmentRepetitions,
    onValueChange: e => setAppointmentRepetitions(e.value),
    className: "w-100",
    min: 1
  }))))), /*#__PURE__*/React.createElement("div", {
    className: "d-flex justify-content-between"
  }, /*#__PURE__*/React.createElement("button", {
    type: "button",
    className: "btn btn-secondary",
    onClick: () => handleClear()
  }, "Limpiar"), /*#__PURE__*/React.createElement("button", {
    type: "button",
    className: "btn btn-primary",
    onClick: handleSubmit(addAppointments)
  }, editingId && appointments.find(a => a.uuid === editingId) ? 'Actualizar cita' : 'Agregar cita'))), /*#__PURE__*/React.createElement("div", {
    className: "col-md-5"
  }, /*#__PURE__*/React.createElement("h5", null, "Citas programadas"), /*#__PURE__*/React.createElement("hr", null), appointments.length === 0 ? /*#__PURE__*/React.createElement("p", {
    className: "text-muted"
  }, "No hay citas programadas") : /*#__PURE__*/React.createElement("div", {
    className: "d-flex flex-column gap-3"
  }, appointments.map(appointment => {
    const hasErrors = Object.keys(appointment.errors).length > 0;
    return /*#__PURE__*/React.createElement("div", {
      key: `${appointment.uuid}-${Object.keys(appointment.errors).length}`,
      className: `card ${hasErrors ? 'border-danger' : ''}`
    }, /*#__PURE__*/React.createElement("div", {
      className: "card-body"
    }, /*#__PURE__*/React.createElement("div", {
      className: "mb-2"
    }, /*#__PURE__*/React.createElement("div", {
      className: "d-flex justify-content-between"
    }, /*#__PURE__*/React.createElement("p", {
      className: "card-text mb-1"
    }, "Fecha: ", appointment.appointment_date?.toLocaleDateString()), hasErrors && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(AppointmentErrorIndicator, {
      appointmentId: appointment.uuid,
      errors: appointment.errors
    }))), /*#__PURE__*/React.createElement("p", {
      className: "card-text"
    }, "Hora: ", appointment.appointment_time)), /*#__PURE__*/React.createElement("div", {
      className: "d-flex justify-content-end gap-2"
    }, /*#__PURE__*/React.createElement("button", {
      type: "button",
      className: "btn btn-sm btn-outline-primary",
      onClick: () => handleEdit(appointment)
    }, /*#__PURE__*/React.createElement("i", {
      className: "fas fa-pencil-alt"
    })), /*#__PURE__*/React.createElement("button", {
      type: "button",
      className: "btn btn-sm btn-outline-primary",
      onClick: () => handleCopy(appointment)
    }, /*#__PURE__*/React.createElement("i", {
      className: "fas fa-copy"
    })), /*#__PURE__*/React.createElement("button", {
      type: "button",
      className: "btn btn-sm btn-outline-danger",
      onClick: () => handleRemove(appointment.uuid)
    }, /*#__PURE__*/React.createElement("i", {
      className: "fas fa-trash-alt"
    })))));
  }), hasValidationErrors() && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    className: "d-flex justify-content-end"
  }, /*#__PURE__*/React.createElement("button", {
    type: "button",
    className: "btn btn-sm btn-primary",
    onClick: async () => {
      const validated = await validateAppointments(appointments);
      setAppointments(validated);
    }
  }, "Validar citas")))))))), /*#__PURE__*/React.createElement("div", {
    className: "d-flex justify-content-end gap-2"
  }, /*#__PURE__*/React.createElement("button", {
    className: "btn btn-link text-danger px-3 my-0",
    "aria-label": "Close",
    type: "button",
    onClick: onClose
  }, /*#__PURE__*/React.createElement("i", {
    className: "fas fa-arrow-left"
  }), " Cerrar"), /*#__PURE__*/React.createElement("button", {
    type: "submit",
    className: "btn btn-primary my-0",
    disabled: !formValid || hasValidationErrors()
  }, /*#__PURE__*/React.createElement("i", {
    className: "fas fa-bookmark"
  }), " Guardar"))));
};
const AppointmentErrorIndicator = ({
  appointmentId,
  errors
}) => {
  const errorMessages = Object.values(errors).flat();
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Tooltip, {
    target: `#error-${appointmentId}`,
    position: "top"
  }, /*#__PURE__*/React.createElement("div", {
    className: "p-2"
  }, errorMessages.map((msg, i) => /*#__PURE__*/React.createElement("ul", {
    key: i
  }, msg)))), /*#__PURE__*/React.createElement("i", {
    id: `error-${appointmentId}`,
    className: "fas fa-warning p-error cursor-pointer"
  }));
};